## 0082 - Primeros pasos con TechSupport

Hasta el momentoy hemos presentado la clase `ArrayList` de la librería de clases de Java. Hemos visto cómo esta clase nos permitía hacer cosas que de otro modo serían difíciles de conseguir (en este caso, almacenar un número arbitrario de objetos).

Esa clase era un sencillo ejemplo de las múltiples clases útiles que contiene la librería Java. La librería está compuesta por miles de clases, muchas de las cuales serán por lo general útiles para nuestro trabajo de programación, aunque también hay disponibles muchas otras que probablemente nunca utilizaremos.

Para un buen programador de Java, es esencial ser capaz de trabajar con la librería Java y tomar decisiones adecuadas acerca de qué clases utilizar. Una vez que hayas empezado a trabajar con la librería de Java, comprobarás rápidamente que te permite realizar numerosas tareas de manera mucho más fácil que si no dispusiera de ella. Aprender a trabajar con las clases de librería es el tema principal a partir de ahora.

Los elementos de la librería no son solo un conjunto de clases arbitrarias y no relacionadas que tengamos que aprender individualmente, sino que a menudo están organizadas en forma relaciones para aprovechar características comunes. Aquí, volvemos a encontrarnos con el concepto de abstracción, que nos ayudará a tratar con grandes cantidades de información. Una de las partes más importante de la librería son las colecciones, de las que la clase `ArrayList` es solo un ejemplo.

Veremos a partir de ahora otros tipos de colecciones en este capítulo y comprobaremos que comparten muchos atributos, por lo que a menudo podremos abstraernos de los detalles específicos de una colección concreta y hablar de clases de colección en general.

Presentaremos y explicaremos nuevas clases de colección, así como algunas otras clases de utilidad. Para ello a partir de este momento trabajaremos en la construcción de una única aplicación (el sistema *TechSupport*), que hace uso de distintas clases de librería. 

Vamos a empezar con una una versión inicial muy simple del proyecto, para luego ir desarrollando e implementando una solución más completa.

La aplicación hace uso de varias nuevas técnicas y clases de librería, cada una de las cuales requiere un estudio individual, como mapas hash, conjuntos, extracción de símbolos en cadenas de caracteres y uso avanzado de los números aleatorios. 

La librería Java estándar es enorme. Está formada por miles de clases, cada una de las cuales tiene muchos métodos, que a su vez pueden tener o no parámetros, contener o no tipos de retorno. Es imposible memorizar todos los métodos y los detalles correspondientes a cada uno. En lugar de ello, lo que un buen programador Java debe hacer es:

- Conocer por su nombre algunas de las clases más importantes y sus métodos (`ArrayList` es una de esas clases importantes).
- Saber localizar información acerca de esas clases y buscar los correspondientes detalles (como, por ejemplo, métodos y parámetros).

Para ello es fundamental aprender a explorar y comprender la librería. Esto re permitirá escribir programas mucho más interesantes. Afortunadamente, la librería Java está muy bien documentada. Esta documentación está disponible en formato HTML (por lo que se puede leer en un explorador web), que será la aplicación que utilizaremos para conseguir información acerca de las clases de librería.

Leer y comprender la documentación es la primera etapa de nuestra introducción a las clases de librería. Llevaremos este enfoque un poco más allá y veremos también cómo preparar nuestras propias clases para que otras personas puedan utilizarlas de la misma forma que usarían las clases de la librería estándar. Esto tiene una gran importancia para el desarrollo de software en el mundo real, donde los equipos de trabajo tienen que tratar con proyectos de gran envergadura y han de encargarse del mantenimiento del software a lo largo del tiempo.

Una cosa que puedes haber observado acerca de la clase `ArrayList` es que la hemos utilizado sin haber echado siquiera un vistazo a su código fuente. No nos molestamos en comprobar cómo estaba implementada, porque no lo necesitábamos para hacer uso de su funcionalidad. Lo único que necesitábamos era el nombre de la clase, los nombres de los métodos, los parámetros y tipos de retorno de esos métodos y qué es lo que esos métodos hacen exactamente. Realmente no nos preocupaba cómo se llevaba a cabo ese trabajo. Esta situación es típica a la hora de utilizar clases de librería.

Lo mismo cabe decir de esas clases de proyectos de software de gran tamaño. Normalmente, varias personas trabajan juntas en un proyecto encargándose de distintas partes del mismo. Cada programador debe concentrarse en su propia área y no necesita comprender los detalles de las restantes partes (ya hemos hablado de esto al presentar los conceptos de abstracción y modularización). De hecho, cada programador debe ser capaz de utilizar las clases de otros miembros del equipo como si fueran clases de librería, haciendo un uso juicioso de ellas, pero sin necesidad de saber cómo funcionan internamente.

Para que esto funcione, cada miembro del equipo debe escribir documentación acerca de su clase de forma similar a la documentación que existe para la librería estándar de Java; esta documentación permite a otras personas utilizar una clase sin necesidad de leer su código.

Como ya hemos dicho, vamos a explorar todas estas cuestiones con un ejemplo. Esta vez, utilizaremos la aplicación *tech-support-v1*. Clónala de la página de Github del profesor.

*TechSupport* es un programa que pretende proporcionar soporte técnico para los clientes de una compañía de software ficticia denominada DodgySoft. Hace tiempo, DodgySoft tenía un departamento de soporte técnico, con personas atendiendo una serie de teléfonos. Los clientes podían llamar para pedir consejo y solicitar ayuda acerca de sus problemas técnicos con los productos software de DodgySoft. Sin embargo, recientemente los negocios no han ido tan bien, por lo que DodgySoft decidió deshacerse de su departamento de soporte técnico con el fin de ahorrar
dinero. Ahora, quieren desarrollar el sistema *TechSupport* para dar la impresión de que se sigue proporcionando soporte. Se supone que el sistema debe simular las respuestas que una persona de soporte técnico daría. Los clientes pueden comunicarse con el sistema de soporte técnico a través de Internet.

El proyecto que has descargado se trata de una primera implementación rudimentaria de nuestro sistema (implementación que iremos mejorando a partir de ahora). Crea un objet ode la clase `SupportSystem` e invoca el método `start`. El programa básicamente se dedica a mantener un diálogo con el usuario. El usuario puede escribir una pregunta y el sistema responde. El diálogo finaliza cuando el usuario escribe `bye`.

En la versión prototipo que estamos utilizando como punto de partida, las respuestas son bastane restringidas. Comprobarás rápidamente que la respuesta es siempre la misma:

*"That sounds interesting. Tell me more ." ("Parece interesante. Cuénteme más..." )*

Esto, de hecho, no resulta interesante en absoluto, y tampoco es muy convincente a la hora de tratar de simular que tenemos una persona de soporte técnico al otro lado de la pantalla. En breve, trataremos de mejorar este aspecto. Sin embargo, antes de hacerlo, vamos a explorar con más detalle lo que hasta ahora tenemos.

El diagrama del proyecto que aparece en BlueJ nos muestra tres clases: `SupportSystem`, `InputReader` y `Responder`. `SupportSystem` es la clase principal, que utiliza `InputReader` para obtener entradas escritas por el usuario desde el terminal y `Responder` es la clase que se encarga de generar una respuesta.

Examina ahora con más detalle la clase `InputReader` creando un objeto de esta clase y luego echando un vistazo a los métodos de ese objeto. Verás que solo tiene un método disponible, denominado `getInput`, que devuelve una cadena de caracteres. Prueba ese método. El método permite escribir una línea de entrada en el terminal y luego devuelve como resultado del método lo que fuera que hayamos escrito. Por el momento no analizaremos cómo funciona internamente la clase `InputReader`, así que quédate
con la idea de que `InputReader` tiene un método `getInput` que devuelve una cadena de caracteres.

Haz lo mismo con la clase `Responder` (es decir, crea un objeto de esa clase y prueba sus métodos). Comprobarás que tiene un método generateResponse que siempre devuelve la cadena "*That sounds interesting. Tell me more*" Esto explica lo que hemos visto anteriormente en el diálogo.

Examina ahora con más detalle la clase SupportSystem y la clase Responder leyendo su código fuente. Verás que el código fuente de la clase `Responder` es trivial. Tiene solo un método, que siempre devuelve la misma cadena de caracteres. Esto es algo que mejoraremos más adelante.

Por el momento, vamos a concentrarnos en la clase `SupportSystem`. Esta clase declara dos atributos capaces de almacenar un objeto `InputReader` y un objeto `Responder`, y crea y asigna dos nuevos objetos de esos tipos a sus atributos dentro de su constructor.

Al final, tiene dos métodos denominados `printWelcome` y `printGoodbye`. Estos métodos simplemente imprimen un texto: un mensaje de bienvenida y un mensaje de despedida, respectivamente.

La parte más interesante del código es el método que se encuentra hacia la mitad del listado: el método `start`. Vamos a ver este método más detalladamente.

Al principio del método hay una llamada a `printWelcome` y, al final, otra llamada a `printGoodbye`. Estas dos llamadas se encargan de imprimir los correspondientes mensajes de texto en los momentos apropiados. El resto del método consta de una declaración de una variable booleana y de un bucle while. La estructura es:

    boolean finished false;
    while (finished) {
    	hacer algo
    	if (condición de salida) {
    		finished = true;
    	else {
    		hacer algo más
    	}
    }

Este patrón de código es una variante de la estructura de bucle while que ya habíamos explicado. Utilizamos `finished` como indicador que toma el valor `true` cuando queremos finalizar el bucle (y con él, el programa completo). Por supuesto, nos aseguramos de que ese indicador tome inicialmente el valor `false`. (Recuerda que el signo de exclamación es un operador *not*).

La parte principal del bucle (la parte que se repite una y otra vez mientras deseamos continuar) está compuesta por tres instrucciones, si dejamos de lado la comprobación de la condición de salida:

    String innput = reader.getlnput();
    ...
    String response = responder.generateResponse();
    System.out.println(response);

Por tanto, lo que el bucle hace repetidamente es:

1. Leer una entrada de usuario.
2. Pedir al generador de respuestas que genere una respuesta nueva.
3. Imprimir esa respuesta.

(Ya habrás observado que la respuesta no depende de la entrada en absoluto. Por supuesto, eso es algo que tendremos que mejorar más adelante).

La última parte que tenemos que examinar es la comprobación de la condición de salida. La intención es que el programa termine cuando el usuario escriba la palabra `bye`. La sección relevante del código fuente de la clase es la siguiente:

    String input = reader.getlnput();
    if (input.startsWith("bye")) {
    	finished = true;
    }

Si eres capaz de entender estos fragmentos aisladamente, entonces conviene que examine de nuevo el método `start` completo para ver si puedes comprender cómo funciona todo el conjunto.

En el último fragmento de código que acabamos de examinar, se utiliza un método denominado `startsWith`. Dado que ese método se invoca sobre la variable `input`, que almacena un objeto `String`, este método `startsWith` debe ser un método de la clase `String`. ¿Pero qué es lo que hace ese método? ¿Y cómo podemos averiguarlo?

Podemos adivinar, simplemente viendo el nombre del método, que el método comprueba si la cadena de entrada comienza con la palabra "bye". Verificamos esta suposición haciendo algunos experimentos. Ejecuta de nuevo el sistema *TechSupport* y escribe "bye bye" o "bye everyone". Observarás que ambas versiones hacen que el programa termine. Sin embargo, observa que si escribimos "Bye" o " bye", comenzando con una letra mayúscula o con espacio delante de la palabra, entonces no se reconoce que la cadena comience por "bye". Esto podría resultar algo molesto para el usuario, pero en realidad podemos resolver estos problemas con solo saber algo más acerca de
la clase `String`.

¿Cómo podemos encontrar más información acerca del método `startsWith` o de los restantes métodos de la clase `String`? La clase `String` es una de las clases de la librería estándar de clases Java. Podemos conocer más detalles acerca de la misma leyendo la documentación de librería para la clase `String`. Para ello, basta con que realices una búsqueda en Google de "java 8 api" (en vez de 8 puedes indicar el número de versión de Java que estés utilizando); el primer resultado te llevará a una página web mostrando la página principal de la documentación de la API (Application Programming Interface, Interfaz de programación de aplicaciones) de Java.

Si la versión de Java de la API que estás consultando es la 8 o inferior rl explorador web mostrará tres marcos; si es la 9 o superior, solo mostrará uno (pero puedes hacer que se muestren los 3 marcos usando el botón "Frames" de la parte superior izquierda. En el marco situado en la parte superior izquierda podrás ver una lista de paquetes. Debajo de él verás una lista de todas las clases de la librería Java. El marco más grande situado a la derecha se emplea para mostrar los detalles de un paquete o clase seleccionado.

En la lista de clases de la izquierda, localiza y selecciona la clase `String`. El marco de la derecha mostrará entonces la documentación de la clase `String`.

Para una explicación adicional de lo visto hasta el momento puedes ver el siguiente vídeo:

 <div align="center">
<a href="https://youtu.be/ldcycoCb_pA"><img src="https://img.youtube.com/vi/ldcycoCb_pA/0.jpg" ></a>
</div>
<br>

Se pide ahora que busques las respuestas a las siguientes preguntas:

- Investiga la documentación de la clase `String` y de otro par de clases a tu elección. ¿Cómo es la estructura de la documentación de una clase (marco principal)? ¿Qué secciones son comunes a la documentación de todas las clases? Escribe tu respuesta en el bloc de notas y toma una captura de pantalla.
- Consulta el método `startsWith` de la clase `String`. ¿Cuántas versiones hay de este método? ¿Qué diferencias hay entre una y otra? Escribe código en el CodePad de BlueJ para testear ambos métodos de forma que obtengas como valores devueltos `true` o `false` para los dos métodos `startsWith` disponibles. Toma una captura de pantalla.
- ¿Hay algún método en la clase `String` que compruebe si una cadena termina con un
determinado sufijo? Si existe, ¿cuál es? Escribe código en el CodePad de BlueJ para testear este método de forma que obtengas valores devueltos `true` o `false`. Toma una captura de pantalla.
- ¿Hay algún método en la clase `String` que devuelva el número de caracteres de una cadena? Si existe, ¿cuál es?, ¿qué parámetros lleva?, ¿que tipo de valor devuelve? Escribe código en el Codepad de BlueJ para testear este método. Toma una captura de pantalla.

Una vez terminada, puedes ver el siguiente vídeo:

 <div align="center">
<a href="https://youtu.be/8kkYVBJf92s"><img src="https://img.youtube.com/vi/8kkYVBJf92s/0.jpg" ></a>
</div>
<br>

Entrega las cuatro capturas de pantalla solicitadas.
